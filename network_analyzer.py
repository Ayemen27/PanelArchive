
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ŸÜÿ∏ÿßŸÖ ŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸàÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™
Network Security Analyzer - ŸÅÿ≠ÿµ ÿ¥ÿßŸÖŸÑ ŸÑŸÑÿ¥ÿ®ŸÉÿ© ŸàÿßŸÑÿÆÿØŸÖÿßÿ™
"""

import os
import re
import json
import socket
import subprocess
import datetime
import ssl
import requests
from typing import Dict, List, Any, Optional

class NetworkAnalyzer:
    def __init__(self):
        self.results = {
            'open_ports': [],
            'active_connections': [],
            'dns_settings': [],
            'ssl_certificates': [],
            'external_connections': [],
            'firewall_rules': [],
            'network_interfaces': [],
            'security_issues': []
        }
        
        # ŸÖŸÜÿßŸÅÿ∞ ŸÖŸáŸÖÿ© ŸÑŸÑŸÅÿ≠ÿµ
        self.important_ports = [
            21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995,
            3306, 5432, 6379, 27017, 3000, 5000, 8000, 8080, 8443
        ]
        
        # ÿÆÿØŸÖÿßÿ™ ŸÖÿπÿ±ŸàŸÅÿ©
        self.port_services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S',
            3306: 'MySQL', 5432: 'PostgreSQL', 6379: 'Redis',
            27017: 'MongoDB', 3000: 'Node.js', 5000: 'Flask',
            8000: 'HTTP Alt', 8080: 'HTTP Proxy', 8443: 'HTTPS Alt'
        }
    
    def scan_network(self) -> Dict[str, Any]:
        """ŸÅÿ≠ÿµ ÿ¥ÿßŸÖŸÑ ŸÑŸÑÿ¥ÿ®ŸÉÿ©"""
        print("üåê ÿ®ÿØÿ° ŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸàÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™...")
        
        self._scan_open_ports()
        self._scan_active_connections()
        self._check_dns_settings()
        self._scan_ssl_certificates()
        self._check_external_connections()
        self._check_firewall_status()
        self._scan_network_interfaces()
        self._analyze_network_security()
        
        return self.results
    
    def _scan_open_ports(self):
        """ŸÅÿ≠ÿµ ÿßŸÑŸÖŸÜÿßŸÅÿ∞ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©"""
        print("üîç ŸÅÿ≠ÿµ ÿßŸÑŸÖŸÜÿßŸÅÿ∞ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©...")
        
        for port in self.important_ports:
            if self._is_port_open('127.0.0.1', port):
                service = self.port_services.get(port, 'Unknown')
                port_info = {
                    'port': port,
                    'service': service,
                    'status': 'open',
                    'protocol': 'tcp',
                    'timestamp': datetime.datetime.now().isoformat()
                }
                
                # ŸÅÿ≠ÿµ ÿ•ÿ∂ÿßŸÅŸä ŸÑŸÑÿÆÿØŸÖÿ©
                service_info = self._get_service_info(port)
                if service_info:
                    port_info.update(service_info)
                
                self.results['open_ports'].append(port_info)
    
    def _is_port_open(self, host: str, port: int, timeout: int = 3) -> bool:
        """ŸÅÿ≠ÿµ ŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖŸÜŸÅÿ∞ ŸÖŸÅÿ™Ÿàÿ≠"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def _get_service_info(self, port: int) -> Optional[Dict[str, Any]]:
        """ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ÿπŸÜ ÿßŸÑÿÆÿØŸÖÿ©"""
        try:
            if port == 80:
                response = requests.get('http://127.0.0.1', timeout=5)
                return {
                    'server': response.headers.get('Server', 'Unknown'),
                    'status_code': response.status_code
                }
            elif port == 443:
                response = requests.get('https://127.0.0.1', timeout=5, verify=False)
                return {
                    'server': response.headers.get('Server', 'Unknown'),
                    'status_code': response.status_code,
                    'ssl_enabled': True
                }
        except:
            pass
        return None
    
    def _scan_active_connections(self):
        """ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©"""
        print("üîó ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑŸÜÿ¥ÿ∑ÿ©...")
        
        try:
            # ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ netstat ŸÑŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™
            result = subprocess.run(['netstat', '-tuln'], capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines[2:]:  # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ
                    parts = line.split()
                    if len(parts) >= 4:
                        connection = {
                            'protocol': parts[0],
                            'local_address': parts[3],
                            'state': parts[5] if len(parts) > 5 else 'LISTEN',
                            'timestamp': datetime.datetime.now().isoformat()
                        }
                        self.results['active_connections'].append(connection)
        except Exception as e:
            print(f"‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™: {str(e)}")
    
    def _check_dns_settings(self):
        """ŸÅÿ≠ÿµ ÿ•ÿπÿØÿßÿØÿßÿ™ DNS"""
        print("üåç ŸÅÿ≠ÿµ ÿ•ÿπÿØÿßÿØÿßÿ™ DNS...")
        
        try:
            # ŸÇÿ±ÿßÿ°ÿ© ŸÖŸÑŸÅ resolv.conf
            resolv_conf = '/etc/resolv.conf'
            if os.path.exists(resolv_conf):
                with open(resolv_conf, 'r') as f:
                    content = f.read()
                
                dns_servers = re.findall(r'nameserver\s+(\S+)', content)
                for dns in dns_servers:
                    self.results['dns_settings'].append({
                        'server': dns,
                        'type': 'nameserver',
                        'source': resolv_conf
                    })
        except Exception as e:
            print(f"‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ≠ÿµ DNS: {str(e)}")
    
    def _scan_ssl_certificates(self):
        """ŸÅÿ≠ÿµ ÿ¥ŸáÿßÿØÿßÿ™ SSL"""
        print("üîê ŸÅÿ≠ÿµ ÿ¥ŸáÿßÿØÿßÿ™ SSL...")
        
        ssl_dirs = ['ssl/', 'ssl_init/', 'data/']
        for ssl_dir in ssl_dirs:
            if os.path.exists(ssl_dir):
                for root, dirs, files in os.walk(ssl_dir):
                    for file in files:
                        if file.endswith(('.pem', '.crt', '.cert')):
                            cert_path = os.path.join(root, file)
                            cert_info = self._analyze_ssl_certificate(cert_path)
                            if cert_info:
                                self.results['ssl_certificates'].append(cert_info)
    
    def _analyze_ssl_certificate(self, cert_path: str) -> Optional[Dict[str, Any]]:
        """ÿ™ÿ≠ŸÑŸäŸÑ ÿ¥ŸáÿßÿØÿ© SSL"""
        try:
            # ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑÿ¥ŸáÿßÿØÿ©
            with open(cert_path, 'r') as f:
                cert_content = f.read()
            
            # ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ£ÿ≥ÿßÿ≥Ÿäÿ©
            cert_info = {
                'path': cert_path,
                'type': 'ssl_certificate',
                'file_size': os.path.getsize(cert_path),
                'timestamp': datetime.datetime.now().isoformat()
            }
            
            # ŸÅÿ≠ÿµ ÿ•ÿ∂ÿßŸÅŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ openssl ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ŸàŸÅÿ±
            try:
                result = subprocess.run([
                    'openssl', 'x509', '-in', cert_path, '-text', '-noout'
                ], capture_output=True, text=True)
                
                if result.returncode == 0:
                    output = result.stdout
                    
                    # ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ŸáÿßÿØÿ©
                    if 'Subject:' in output:
                        subject_match = re.search(r'Subject:(.+)', output)
                        if subject_match:
                            cert_info['subject'] = subject_match.group(1).strip()
                    
                    if 'Issuer:' in output:
                        issuer_match = re.search(r'Issuer:(.+)', output)
                        if issuer_match:
                            cert_info['issuer'] = issuer_match.group(1).strip()
                    
                    # ŸÅÿ≠ÿµ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©
                    not_after_match = re.search(r'Not After : (.+)', output)
                    if not_after_match:
                        cert_info['expires'] = not_after_match.group(1).strip()
            except:
                pass
            
            return cert_info
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ¥ŸáÿßÿØÿ© {cert_path}: {str(e)}")
            return None
    
    def _check_external_connections(self):
        """ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©"""
        print("üåê ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©...")
        
        # ŸÅÿ≠ÿµ ŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ŸÑŸÑÿ®ÿ≠ÿ´ ÿπŸÜ URLs ÿÆÿßÿ±ÿ¨Ÿäÿ©
        config_files = []
        for root, dirs, files in os.walk('.'):
            for file in files:
                if file.endswith(('.conf', '.cfg', '.json', '.py')):
                    config_files.append(os.path.join(root, file))
        
        url_pattern = r'https?://[^\s"\'\]>)]+|[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
        
        for config_file in config_files[:50]:  # ÿ≠ÿØ ÿ£ŸÇÿµŸâ 50 ŸÖŸÑŸÅ
            try:
                with open(config_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                urls = re.findall(url_pattern, content)
                for url in urls:
                    if not url.startswith(('127.0.0.1', 'localhost', '192.168.', '10.')):
                        self.results['external_connections'].append({
                            'url': url,
                            'source_file': config_file,
                            'type': 'external_url',
                            'timestamp': datetime.datetime.now().isoformat()
                        })
            except:
                continue
    
    def _check_firewall_status(self):
        """ŸÅÿ≠ÿµ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ¨ÿØÿßÿ± ÿßŸÑŸÜÿßÿ±Ÿä"""
        print("üõ°Ô∏è ŸÅÿ≠ÿµ ÿßŸÑÿ¨ÿØÿßÿ± ÿßŸÑŸÜÿßÿ±Ÿä...")
        
        try:
            # ŸÅÿ≠ÿµ iptables
            result = subprocess.run(['iptables', '-L'], capture_output=True, text=True)
            if result.returncode == 0:
                rules = result.stdout.strip().split('\n')
                for rule in rules:
                    if rule.strip() and not rule.startswith('Chain'):
                        self.results['firewall_rules'].append({
                            'rule': rule.strip(),
                            'type': 'iptables',
                            'timestamp': datetime.datetime.now().isoformat()
                        })
        except:
            pass
        
        try:
            # ŸÅÿ≠ÿµ ufw
            result = subprocess.run(['ufw', 'status'], capture_output=True, text=True)
            if result.returncode == 0:
                self.results['firewall_rules'].append({
                    'rule': result.stdout.strip(),
                    'type': 'ufw',
                    'timestamp': datetime.datetime.now().isoformat()
                })
        except:
            pass
    
    def _scan_network_interfaces(self):
        """ŸÅÿ≠ÿµ Ÿàÿßÿ¨Ÿáÿßÿ™ ÿßŸÑÿ¥ÿ®ŸÉÿ©"""
        print("üîå ŸÅÿ≠ÿµ Ÿàÿßÿ¨Ÿáÿßÿ™ ÿßŸÑÿ¥ÿ®ŸÉÿ©...")
        
        try:
            result = subprocess.run(['ip', 'addr', 'show'], capture_output=True, text=True)
            if result.returncode == 0:
                interfaces = result.stdout.strip()
                
                # ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸàÿßÿ¨Ÿáÿßÿ™
                interface_blocks = re.split(r'\n(?=\d+:)', interfaces)
                for block in interface_blocks:
                    if block.strip():
                        lines = block.strip().split('\n')
                        if lines:
                            interface_line = lines[0]
                            interface_name = re.search(r'\d+:\s+(\w+):', interface_line)
                            if interface_name:
                                name = interface_name.group(1)
                                
                                # ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿπŸÜÿßŸàŸäŸÜ IP
                                ip_addresses = re.findall(r'inet\s+(\S+)', block)
                                
                                self.results['network_interfaces'].append({
                                    'name': name,
                                    'ip_addresses': ip_addresses,
                                    'status': 'UP' if 'UP' in interface_line else 'DOWN',
                                    'timestamp': datetime.datetime.now().isoformat()
                                })
        except Exception as e:
            print(f"‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ≠ÿµ Ÿàÿßÿ¨Ÿáÿßÿ™ ÿßŸÑÿ¥ÿ®ŸÉÿ©: {str(e)}")
    
    def _analyze_network_security(self):
        """ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ŸÖÿßŸÜ ÿßŸÑÿ¥ÿ®ŸÉŸä"""
        issues = []
        
        # ŸÅÿ≠ÿµ ÿßŸÑŸÖŸÜÿßŸÅÿ∞ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿßŸÑÿÆÿ∑Ÿäÿ±ÿ©
        dangerous_ports = [21, 23, 3306, 5432, 6379, 27017]
        open_dangerous = [p for p in self.results['open_ports'] if p['port'] in dangerous_ports]
        
        if open_dangerous:
            issues.append({
                'severity': 'high',
                'type': 'dangerous_ports_open',
                'count': len(open_dangerous),
                'description': 'ŸÖŸÜÿßŸÅÿ∞ ÿÆÿ∑Ÿäÿ±ÿ© ŸÖŸÅÿ™Ÿàÿ≠ÿ©',
                'ports': [p['port'] for p in open_dangerous]
            })
        
        # ŸÅÿ≠ÿµ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ÿßŸÑŸÖÿ¥ÿ®ŸàŸáÿ©
        external_count = len(self.results['external_connections'])
        if external_count > 20:
            issues.append({
                'severity': 'medium',
                'type': 'too_many_external_connections',
                'count': external_count,
                'description': 'ÿπÿØÿØ ŸÉÿ®Ÿäÿ± ŸÖŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©'
            })
        
        # ŸÅÿ≠ÿµ ÿ¥ŸáÿßÿØÿßÿ™ SSL ŸÖŸÜÿ™ŸáŸäÿ© ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©
        expired_certs = []
        for cert in self.results['ssl_certificates']:
            if 'expires' in cert:
                # ŸÅÿ≠ÿµ ÿ®ÿ≥Ÿäÿ∑ ŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ŸÖŸÜÿ™ŸáŸäÿ©
                if 'expired' in cert['expires'].lower():
                    expired_certs.append(cert)
        
        if expired_certs:
            issues.append({
                'severity': 'medium',
                'type': 'expired_ssl_certificates',
                'count': len(expired_certs),
                'description': 'ÿ¥ŸáÿßÿØÿßÿ™ SSL ŸÖŸÜÿ™ŸáŸäÿ© ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©'
            })
        
        self.results['security_issues'] = issues
    
    def generate_report(self) -> Dict[str, Any]:
        """ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ¥ÿ®ŸÉÿ©"""
        summary = {
            'open_ports_count': len(self.results['open_ports']),
            'active_connections_count': len(self.results['active_connections']),
            'ssl_certificates_count': len(self.results['ssl_certificates']),
            'external_connections_count': len(self.results['external_connections']),
            'network_interfaces_count': len(self.results['network_interfaces']),
            'security_issues_count': len(self.results['security_issues']),
            'scan_timestamp': datetime.datetime.now().isoformat()
        }
        
        return {
            'summary': summary,
            'findings': self.results,
            'recommendations': self._get_network_recommendations()
        }
    
    def _get_network_recommendations(self) -> List[str]:
        """ÿ™ŸàÿµŸäÿßÿ™ ÿ£ŸÖÿßŸÜ ÿßŸÑÿ¥ÿ®ŸÉÿ©"""
        recommendations = []
        
        if any(p['port'] in [21, 23] for p in self.results['open_ports']):
            recommendations.append("üö´ ÿ•ÿ∫ŸÑÿßŸÇ ÿÆÿØŸÖÿßÿ™ FTP Ÿà Telnet ÿ∫Ÿäÿ± ÿßŸÑÿ¢ŸÖŸÜÿ©")
        
        if any(p['port'] in [3306, 5432, 6379] for p in self.results['open_ports']):
            recommendations.append("üîí ÿ™ÿ£ŸÖŸäŸÜ ŸÇŸàÿßÿπÿØ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ Ÿàÿ™ŸÇŸäŸäÿØ ÿßŸÑŸàÿµŸàŸÑ")
        
        if not self.results['firewall_rules']:
            recommendations.append("üõ°Ô∏è ÿ™ŸÅÿπŸäŸÑ Ÿàÿ™ŸÉŸàŸäŸÜ ÿßŸÑÿ¨ÿØÿßÿ± ÿßŸÑŸÜÿßÿ±Ÿä")
        
        recommendations.extend([
            "üîê ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ¥ŸáÿßÿØÿßÿ™ SSL ÿµÿßŸÑÿ≠ÿ©",
            "üåê ŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©",
            "üìä ŸÖÿ±ÿßÿ¨ÿπÿ© ÿßŸÑŸÖŸÜÿßŸÅÿ∞ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿ®ÿßŸÜÿ™ÿ∏ÿßŸÖ",
            "üîÑ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ∏ÿßŸÖ ŸàÿßŸÑÿÆÿØŸÖÿßÿ™"
        ])
        
        return recommendations

def main():
    analyzer = NetworkAnalyzer()
    print("üåê ÿ®ÿØÿ° ŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸàÿßŸÑÿßÿ™ÿµÿßŸÑÿßÿ™...")
    
    results = analyzer.scan_network()
    report = analyzer.generate_report()
    
    # ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±
    with open('network_analysis_report.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, ensure_ascii=False, indent=2)
    
    print(f"‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ŸÅÿ≠ÿµ ÿßŸÑÿ¥ÿ®ŸÉÿ©: network_analysis_report.json")
    print(f"üìä ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨: {report['summary']['open_ports_count']} ŸÖŸÜŸÅÿ∞ ŸÖŸÅÿ™Ÿàÿ≠ÿå {report['summary']['external_connections_count']} ÿßÿ™ÿµÿßŸÑ ÿÆÿßÿ±ÿ¨Ÿä")
    
    return report

if __name__ == "__main__":
    main()
